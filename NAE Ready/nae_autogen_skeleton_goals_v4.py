# nae_autogen_skeleton_goals_v4.py
"""
NAE AutoGen Skeleton v4 - Ready-to-run orchestrator

Features:
- Continuous monitoring loop
- Real-time logging
- Messaging flow Ralph -> Casey -> Donnie -> Optimus
- Full Splinter/Bebop oversight
- Compatible with AutoGen v0.9.7
"""

import time
from typing import List, Dict
from agents.ralph import RalphAgent
from agents.casey import CaseyAgent
from agents.donnie import DonnieAgent
from agents.optimus import OptimusAgent
from agents.shredder import ShredderAgent
from agents.phisher import PhisherAgent
from agents.rocksteady import RocksteadyAgent
from agents.bebop import BebopAgent
from agents.splinter import SplinterAgent
from agents.mikey import MikeyAgent
from agents.leo import LeoAgent

# ----------------------
# Initialize all agents
# ----------------------
ralph = RalphAgent()
casey = CaseyAgent()
donnie = DonnieAgent()
optimus = OptimusAgent()
shredder = ShredderAgent()
phisher = PhisherAgent()
rocksteady = RocksteadyAgent()
bebop = BebopAgent()
splinter = SplinterAgent()
mikey = MikeyAgent()
leo = LeoAgent()

assistant_agents = {
    "RalphAgent": ralph,
    "CaseyAgent": casey,
    "DonnieAgent": donnie,
    "OptimusAgent": optimus,
    "ShredderAgent": shredder,
    "PhisherAgent": phisher,
    "RocksteadyAgent": rocksteady,
    "BebopAgent": bebop,
    "SplinterAgent": splinter,
    "MikeyAgent": mikey,
    "LeoAgent": leo
}

# ----------------------
# Messaging function
# ----------------------
def send_message(sender_name: str, receiver_name: str, content: str):
    if receiver_name not in assistant_agents:
        print(f"[NAE WARNING] Receiver {receiver_name} not registered")
        return
    agent = assistant_agents[receiver_name]
    # For simplicity, inject content into agent as a method call
    if hasattr(agent, "receive_message"):
        agent.receive_message(sender_name, content)
    else:
        print(f"[NAE INFO] {receiver_name} has no receive_message() method, logging instead.")
        if hasattr(agent, "log_action"):
            agent.log_action(f"Message from {sender_name}: {content}")

# ----------------------
# Splinter monitoring
# ----------------------
def splinter_monitor_loop():
    print("[NAE] Orchestrator started with Splinter oversight...")
    while True:
        print("[Splinter] Supervisory monitoring cycle start...")
        for agent_name, agent in assistant_agents.items():
            status = getattr(agent, "status", "Unknown")
            print(f"[Splinter] Monitoring {agent_name} | Status: {status}")
        print("[Splinter] Monitoring cycle complete.\n")
        time.sleep(5)  # adjust interval as needed

# ----------------------
# Core agent flow
# ----------------------
def execute_agent_flow():
    # Step 1: Ralph generates strategies
    strategies = ralph.generate_strategies()
    if not strategies:
        print("[NAE] No strategies generated by Ralph")
        return

    # Step 2: Casey receives top strategies for agent refinement
    casey.run(agent_names=["DonnieAgent", "OptimusAgent"], overwrite=True)

    # Step 3: Donnie receives strategies
    donnie.receive_strategies(strategies)

    # Step 4: Donnie executes strategies in sandbox mode first
    donnie.run_cycle(sandbox=True)

    # Step 5: Optionally send approved execution to Optimus live
    for s in donnie.execution_history:
        send_message("DonnieAgent", "OptimusAgent", f"Execute strategy: {s['strategy_name']}")

# ----------------------
# Initial registration / Bebop
# ----------------------
bebop.register_agents(list(assistant_agents.keys()))
splinter.register_agents(list(assistant_agents.keys()))

# ----------------------
# Run orchestrator
# ----------------------
if __name__ == "__main__":
    import threading

    # Start Splinter monitoring loop in separate thread
    monitor_thread = threading.Thread(target=splinter_monitor_loop, daemon=True)
    monitor_thread.start()

    # Run agent execution loop continuously
    while True:
        try:
            execute_agent_flow()
            time.sleep(10)  # adjust execution interval as needed
        except KeyboardInterrupt:
            print("[NAE] Orchestrator interrupted by user. Exiting...")
            break
        except Exception as e:
            print(f"[NAE ERROR] {e}")
            time.sleep(5)
